<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JVM从0到1-内存划分 | 高亮的杂货铺</title>
<meta name="description" content="Happy coding!" />
<link rel="shortcut icon" href="https://gaoliang.me/favicon.ico?v=1584181320081">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://gaoliang.me/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111489730-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-111489730-2');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://gaoliang.me">
  <img class="avatar" src="https://gaoliang.me/images/avatar.png?v=1584181320081" alt="">
  </a>
  <h1 class="site-title">
    高亮的杂货铺
  </h1>
  <p class="site-description">
    Happy coding!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://gaoliang.me/post/experiments" class="menu">
          试验田
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/gaoliang" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
        <a href="https://twitter.com/im_sorghum" target="_blank">
          <i class="fab fa-twitter"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JVM从0到1-内存划分
            </h2>
            <div class="post-info">
              <span>
                2020-03-13
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://gaoliang.me/tag/jvm/" class="post-tag">
                  # JVM
                </a>
              
                <a href="https://gaoliang.me/tag/i6PatO6w0/" class="post-tag">
                  # Java
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>jvm运行时会把内存分为多个数据区域，根据《java虚拟机规范》规定，可以划分为方法区，堆，虚拟机栈，本地方法栈和程序计数器，其中方法区和堆是所有线程所共享的，其他则是每个线程隔离的。<br>
<img src="https://gaoliang.me/post-images/1584113372648.png" alt="" loading="lazy"></p>
<h2 id="程序计数器">程序计数器</h2>
<p>其中记录的是当前所执行的字节码的行号，字节码解释就是通过改变这个计数器来完成包括分支、跳转、循环、异常、线程恢复等基本功能的。当线程执行的是 本地方法时，这个计数器的值为空。 这个区域是《java虚拟机规范》中唯一一个没有规定OOM情况的区域。</p>
<h2 id="java虚拟机栈">Java虚拟机栈</h2>
<p>每个Java方法被执行时，虚拟机都会同步创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，一个方法被调用到执行结束的过程，也就对应着栈帧从入栈到出栈的过程。</p>
<p>《java虚拟机规范》规定这个区域会存在两种一场，栈深度大于虚拟机允许深度时，抛出StackOverFlowError，如果栈容量可以动态扩展，则当无法扩展时，抛出OOM异常。我们常用的HotSpot虚拟机栈容量是不会动态扩展的，但是这并不意味着就不会抛出OOM异常，如果线程申请栈空间失败了，也是会抛出OOM的。</p>
<h2 id="本地方法栈">本地方法栈</h2>
<p>和Java虚拟机栈类似，只是执行的是本地方法，虚拟机规范没有堆这一部分有强制规定，有些虚拟机（例如HotSpot直接把Java虚拟机栈和本地方法栈合并了）</p>
<h2 id="java堆">Java堆</h2>
<p>堆的唯一目的就是存放对象实例。其内部结构并没有进一步的细致划分，我们常说的新生代，老年代，永久代，Eden，Survivor等都是一部分垃圾收集器的设计风格，和虚拟机规范乃至虚拟机实现没有关系。</p>
<p>从分配对象的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）用于提升对象分配的效率。 当Java堆中没有空间完成实例分配，而且堆的大小也没法继续扩展时，虚拟机会抛出OOM异常。</p>
<h2 id="方法区">方法区</h2>
<p>方法区和堆一样，也是各个线程共享的内存区域，这个区域用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器（JIT）编译后的代码缓存等数据。Java虚拟机规范中，把方法区描述为堆的一个逻辑部分，但是他取有一个别名“非堆”（Non-Heap）。<br>
说到方法区，就要提到“永久代”的概念，在JDK8以前，由于HotSpot虚拟机的流行，很多人直接把方法区称之为“永久代”，这种说法是错误的，仅仅是因为在当时HotSpot设计选择把垃圾回收分代的设计扩展到了方法区，或者说，是使用“永久代”来实现了方法区。 原则上，如何设计和实现方法区，Java虚拟机规范并没有要求。在JDK8时，HotSpot虚拟机已经完全抛弃了永久代的概念，改用在本地内存中实现的原空间（Meta Space）来代替。<br>
Java虚拟机规范要求，当方法去无法满足新内存分配需求的时候，会抛出OOM</p>
<h3 id="运行时常量池">运行时常量池</h3>
<p>运行时常量池是方法区的一部分，Class文件中，除了类的版本、字段、方法、接口等描述信息外，还有一项是常量池表，用于存放在编译期间产生的各种字面量和符号引用，这部分内容会在类加载后存放到方法区的运行时常量池中。 Java虚拟机规范堆class文件的每个部分的格式都有要求，例如每个字节用于存储什么数据。 但是，对于运行时常量池，规范并没有给出细节的要求，所以不同的虚拟机实现会按照自己的设计来实现这个区域，一般来说，除了保存Class文件中的符号引用外，还会把由符号引用翻译而来的直接引用也存储到这个运行时常量池中来。</p>
<p>运行时常量池的一个特点是具有动态性，并不要求常量必须在编译期产生，所以并非只有class文件常量池中的内容可以放入运行时常量池，也可以在运行期间放入新的常量，例如String类的intern()方法。</p>
<h2 id="直接内存">直接内存</h2>
<p>首先要注意，直接内存并不属于虚拟机运行时数据区的一部分，也不是虚拟机规范规定的内存区域，但是这一部分也会被频繁使用，也有可能导致OOM。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a></li>
<li><a href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java虚拟机栈</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a></li>
<li><a href="#java%E5%A0%86">Java堆</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a>
<ul>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">直接内存</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://gaoliang.me/post/java-ri-zhi-xi-tong-shu-li/">
              <h3 class="post-title">
                Java 日志系统梳理
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'gao-liang-de-za-huo-pu',
  apikey: 'yetuLkolNo1SQ1c6oRQdEdOLdIpLHymjVOvj23cvFTFwbgwBpfjtGTHKmsSlwdfl',
}
if ('') {
  options.api = ''
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://gaoliang.me/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      console.log('section.offsetHeight', section.offsetHeight);
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>

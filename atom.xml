<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gaoliang.me</id>
    <title>高亮的杂货铺</title>
    <updated>2020-03-14T10:48:42.996Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gaoliang.me"/>
    <link rel="self" href="https://gaoliang.me/atom.xml"/>
    <subtitle>Happy coding!</subtitle>
    <logo>https://gaoliang.me/images/avatar.png</logo>
    <icon>https://gaoliang.me/favicon.ico</icon>
    <rights>All rights reserved 2020, 高亮的杂货铺</rights>
    <entry>
        <title type="html"><![CDATA[JVM从0到1-类加载器]]></title>
        <id>https://gaoliang.me/post/jvm-cong-0-dao-1-lei-jia-zai-qi/</id>
        <link href="https://gaoliang.me/post/jvm-cong-0-dao-1-lei-jia-zai-qi/">
        </link>
        <updated>2020-03-14T09:47:32.000Z</updated>
        <summary type="html"><![CDATA[<p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<!-- more -->
<h2 id="类与类加载器">类与类加载器</h2>
<p>类加载器只用来实现类的加载动作，但在他Java程序中起的作用却远超类加载阶段。 对于任意一个类，都必须由加载他的类加载器和类本身一起确定其在Java虚拟机中的唯一性，也就是说，比较两个类是否是相等的，只有在两个类是同一个类加载器加载的前提下才有意义，否则一定是不相等的。</p>
<h2 id="双亲委派模型">双亲委派模型</h2>
<p>在Java虚拟机的角度来看，只有两种类加载器，一种是启动类加载器(Bootstrap ClassLoader)，用C++实现，是虚拟机自身的一部分；另一种就是其他的类加载器，用Java语言实现，独立与虚拟机之外，而且全部都继承自java.lang.ClassLoader。</p>
<p>在Java开发人员的角度，类加载器应当划分的更细致，从JDK1.2以来，Java一致保持着三层类加载器，双亲委派的类加载结构。</p>
<p>启动类加载器负责加载存在与<code>&lt;JAVA_HOME&gt;\lib</code>目录或者被<code>-Xbootclasspath</code>参数指定的路径中存放的Java虚拟机能够识别的类库加载到虚拟机内存中。 启动类加载器无法被Java程序直接引用，所以当用户编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，例如下面的代码。</p>
<p>扩展类加载器（Extension ClassLoader）：这个类负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，由于是Java语言实现的，所以开发者可以直接在程序中使用扩展类加载器来实现Class文件。</p>
<p>应用程序类加载器（Application Class Loader）这个类加载器是ClassLoader类的getSystemClassLoader方法的返回值，他负责加载用户类路径 ClassPath 上的所有类库，开发这可以直接在代码中使用这个类记载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序默认的类加载器。</p>
<p><img src="https://gaoliang.me/post-images/1584180378027.png" alt="" loading="lazy"><br>
图中展示的各种类加载器之间的层次关系被称为类加载器的双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外，所有的加载器都有自己的父类加载器，但是这里加载器的关系并不是继承，而是通过组合关系来实现复用的。</p>
<p>双亲委派模型的工作过程是当一个类加载器收到加载请求时，他首先不会自己去尝试加载这个类，而是把这个请求传递委派给父类加载器去完成，每一个层级的类加载器都如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器，只有父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。<br>
使用双亲委派模型的一个好处就是Java中的类随着类加载器一起有了优先级的层级关系，例如Java.lang.Object，他存放在rt.jar之中，无论哪个类加载器要加载这个类，最终都是委派给处于最顶端的启动类加载器进行加载，因此Object类在程序的各个类加载器环境中都能保证是一个类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM从0到1-类加载机制]]></title>
        <id>https://gaoliang.me/post/jvm-cong-0-dao-1-lei-jia-zai-ji-zhi/</id>
        <link href="https://gaoliang.me/post/jvm-cong-0-dao-1-lei-jia-zai-ji-zhi/">
        </link>
        <updated>2020-03-14T08:35:06.000Z</updated>
        <summary type="html"><![CDATA[<p>一个类型从被加载到虚拟机内从中，到卸载出内存，整个生命周期会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initilization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个阶段被统称为连接（Linking）</p>
]]></summary>
        <content type="html"><![CDATA[<p>一个类型从被加载到虚拟机内从中，到卸载出内存，整个生命周期会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initilization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个阶段被统称为连接（Linking）</p>
<!-- more -->
<h2 id="何时进行初始化">何时进行初始化？</h2>
<p>对于什么时候进行类的加载，java虚拟机规范并没有强制约束。但是对于初始化阶段，Java虚拟机规范则是严格规定了只有六种情况必须立即对类进行初始化（之前的步骤当然必须也要完成）</p>
<ol>
<li>遇到new、getstatic、putstatic、invokestatic这四条字节码时，如果类型没有初始化，则要先触发其初始化阶段。 对应的情况包括
<ul>
<li>使用new关键字实例化对象。</li>
<li>读取或者设置一个类的静态字段（被final修饰，已经在编译期间把结果放到常量池的静态字段除外）</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用时</li>
<li>当初始化类的时候，如果发现其父类还没有初始化，那么要先触发其父类的初始化</li>
<li>当虚拟机启动时，指定要执行的主类</li>
<li>当使用JDK 7新加入的动态语言支持时</li>
<li>当一个接口中定义了JDK8中新家入的默认方法时，如果有这个接口的实现类，那么这个接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会初始化的常见，Java虚拟机规范中使用了一个非常强烈的限定语，&quot;有且只有&quot;，除此之外，所有引用类型的方法都不会触发初始化，被成为被动引用。 例如，</p>
<ol>
<li>被动使用例子1</li>
</ol>
<pre><code class="language-java">class SuperClass {

    static {
        System.out.println(&quot;SuperClass init!&quot;);
    }

    public static int value = 123;
}

class SubClass extends SuperClass {

    static {
        System.out.println(&quot;SubClass init!&quot;);
    }
}
public class NotInitialization_1 {

    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }

}
</code></pre>
<p>运行这个这个例子，只会输出SuperClass init!，而不会输出SubClass init，这是由于，对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发夫类的初始化，而不会触发子类的初始化。<br>
2. 被动使用例子2 通过数组定义来引用类，不会触发此类的初始化</p>
<pre><code class="language-java">public class NotInitialization_2 {

    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }

}
</code></pre>
<ol start="3">
<li>被动使用例子3 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的</li>
</ol>
<pre><code class="language-java">public class ConstClass {

    static {
        System.out.println(&quot;ConstClass init!&quot;);
    }

    public static final String HELLOWORLD = &quot;hello world&quot;;
}

public class NotInitialization_3 {

    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
</code></pre>
<p>例子三是由于在编译阶段进行了常量传播优化，已经将此常量的值直接存储在了NotInitialization_3类的常量池中，后续对这个常量的引用实际都被转换为对NotInitialization_3类自身常量池的引用了。</p>
<p>此外，还有一个需要注意的，就是接口在初始化时，并不要求其父接口全部都完成初始化，只有在真正使用到父接口的时候，例如引用接口中定义的常量时，才会初始化。</p>
<h2 id="加载">加载</h2>
<p>java虚拟机在加载阶段需要做三件事</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h2 id="验证">验证</h2>
<p>验证是连接阶段的第一步，用于确保class文件是符合java虚拟机规范的约束的。</p>
<ol>
<li>文件格式验证，这一阶段主要验证字节流是否符合class文件的格式。</li>
<li>元数据验证，这一极端会对字节码进行语义分析，验证的点包括这个类是否拥有父类、是否继承了不允许继承的类、如果是非抽象类是否实现了其父类或接口的方法、是否有与父类产生矛盾的字段和方法等。</li>
<li>字节码验证。<br>
字节码验证是整个验证过程中最复杂的一个阶段，主要目的是对数据流分析和控制流分析，确保予以是合法的，主要是对类的方法提，即class文件中的Code属性进行校验，确保校验类的方法不会再运行时做出危害虚拟机安全的行为。  JDK6后，javac和java虚拟机进行了一项联合优化，把尽可能多的校验挪到了javac中进行。具体做法是给Code属性的属性表中加了以”StackMapTable“的新属性，从而降低了运行时进行验证的耗时。</li>
<li>符号引用阶段<br>
这个验证实际发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段，即解析阶段中发生，主要校验符号引用通过字符串描述的全限定名是否能够找到对应的类、方法、字段，以及类、方法、字段的可访问行校验等。</li>
</ol>
<h2 id="准备">准备</h2>
<p>准备阶段是为类中定义的变量（即static变量）分配内存并设置初始化的阶段。从概念上来说，这些变量使用的内存应该在方法代中分配，但必须要注意到方法区本身是一个逻辑上的区域，JDK7之前，HotSpot使用永久代来实现方法区，而在JDK8之后，类变量则会随着class对象一起存放在java堆中，这时候类变量在方法去就完全是一个逻辑概念的表述了。</p>
<p>如果类字段属性表中存在ConstantValue属性，那么准备阶段变量值就会被初始化为ConstantValue所指定的初始化值。</p>
<h2 id="解析">解析</h2>
<p>解析阶段是将常量池中的符号引用转换为直接引用的过程，符号引用包括CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</p>
<h3 id="符号引用symbolic-references">符号引用(Symbolic References)</h3>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何的字面量，只要能找到目标极客，符号引用与虚拟机内存分布无关，引用的目标不一定是加载到虚拟机内存中的内容。 各种虚拟机实现的内存布局可以不同，但是他们接收的符号引用一定是一致的。</p>
<h3 id="直接引用direct-references">直接引用(Direct References)</h3>
<p>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。 他是和虚拟机内存布局有直接关联的，如果有了直接引用，那么被引用的目标一定已经在虚拟机的内存中存在了。</p>
<p>Java虚拟机没有规范解析阶段发生的具体时间。</p>
<h2 id="初始化">初始化</h2>
<p>初始化阶段会根据程序员通过编码制定的计划去初始化变量和其他资源，或者说，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，这个方法并不是程序员直接在java代码中直接编写的，而是javac编译器的产物。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态程序语句块(<code>static{}</code>)中的语句合并产生的 ，编译器收集的顺序由语句在源文件中出现的顺序决定，静态块语句中只能访问到定义在静态块语句之前的变量，定义在他之后的变量，静态块语句可以复制，但是不能访问。例如</p>
<pre><code class="language-java">public class Test {
  static {
    i = 0; // 给变量复制可以正常编译通过
    System.out.print(i); // 这句编译器会提示“非法向前引用”
  }
  static int i = 1;
}
</code></pre>
<p><code>&lt;clinit&gt;()</code>方法并不需要显式的调用父类的构造方法，因为java虚拟机保证子类的<code>&lt;clinit&gt;()</code>执行之前，父类的<code>&lt;clinit&gt;()</code>方法必然已经执行过了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM从0到1-class文件属性表]]></title>
        <id>https://gaoliang.me/post/jvm-cong-0-dao-1-class-wen-jian-shu-xing-biao/</id>
        <link href="https://gaoliang.me/post/jvm-cong-0-dao-1-class-wen-jian-shu-xing-biao/">
        </link>
        <updated>2020-03-14T07:05:58.000Z</updated>
        <summary type="html"><![CDATA[<p>属性表（attribute_info）在前面的讲解中已经出现过多次，class文件、字段表、方法表都可以由自己携带的属性表集合，以描述某些场景专有的信息。虚拟机规范对属性表的限制稍微宽松一些，不要求各个属性具有严格顺序，而且只要不与已有属性崇明，任何人实现的编译其都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时，会忽略它不认识的属性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>属性表（attribute_info）在前面的讲解中已经出现过多次，class文件、字段表、方法表都可以由自己携带的属性表集合，以描述某些场景专有的信息。虚拟机规范对属性表的限制稍微宽松一些，不要求各个属性具有严格顺序，而且只要不与已有属性崇明，任何人实现的编译其都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时，会忽略它不认识的属性。</p>
<!-- more -->
<p>对于每一个属性，他的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构是完全自定义的，只需要通过一个u4长度属性来表明属性值所占用的位数即可。<br>
<img src="https://gaoliang.me/post-images/1584160830127.png" alt="" loading="lazy"></p>
<p>截止到Java虚拟机规范的Java SE 12版本，预定义的属性项已经增加到了29项。详细见后面的表格</p>
<h2 id="code属性">Code属性</h2>
<p>Java程序的方法体经过Javac编译器处理后，最终转换为字节码存储在Code属性中，Code属性出现在方法表中的属性集合之中，但并非所有的方法表都必须有这个属性，比如接口和抽象类中的方法，就不存在Code属性，如果方法表有Code属性存在，那么他的结构如下<br>
<img src="https://gaoliang.me/post-images/1584169843802.png" alt="" loading="lazy"><br>
其中，第一个u2 attriibute_name_index，指向了常量池中的一个utf8类型常量的索引，此常量固定值为Code，attribute_length表示了属性值的长度。</p>
<p>max_stack代表了操作数栈深度的最大值，在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机在运行时根据这个值来分配栈帧中的操作树栈深度。</p>
<p>max_locals代表了局部变量表所需的存储空间，在这里，max_locals的单位是槽(slot)，变量槽是虚拟机为局部变量分配内存的最小单位，对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这种64位的数据类型则需要两个变量槽。 方法参数（包括实例方法中隐含的this）、显示异常处理程序的参数（在catch中定义的异常值）、方法体中定义的局部变量都依赖局部变量表来存放。  但是要注意，并不是方法中有多少个局部变量，就把这些局部变量表所占空间之和作为max_locals的值，操作数栈和局部变量表决定了一个方法的栈帧大小，不必要的数量会导致内存的浪费。 Java虚拟机的做法是将局部变量表的局部变量池进行重用，当代码执行超过一个局部变量的作用域时，这个局部变量所占用的局部变量槽可以被其他局部变量使用，javac编译器会根据变量的作用域来分配变量槽来给各个变量使用，然后根据同时生存的最大局部变量数和类型来计算出max_locals的大小。</p>
<p>code_length和code用来存储Java源程序编译后产生的字节码指令，code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。虽然code_length是一个u4类型的长度值，也就是理论上可以达到2的32次幂，但是根据java虚拟机规范，一个方法不允许超过65535条字节码指令，即实际值使用到了u2的长度。</p>
<p>在字节码指令之后的是显式异常处理表，异常表对于Code属性来说并不是必须存在的。其结构如图<br>
<img src="https://gaoliang.me/post-images/1584171878583.png" alt="" loading="lazy"><br>
字段的含义为，当字节码从start_pc行到end_pc行之间出现了类型为catch_type或者其子类的异常时，则转到第handler_pc行继续处理。 当catch_type的值为0时，代表任意异常情况都需要转到handler_pc行进行处理。</p>
<h2 id="exceptions属性">Exceptions属性</h2>
<p>这个Exceptions属性是方法表中与Code属性同级的一项属性。作用是列举一个方法可能抛出的受检查异常（Checked Exceptions），也就是方法描述时，throws关键字后面列举的异常，其结构如下图<br>
<img src="https://gaoliang.me/post-images/1584173316961.png" alt="" loading="lazy"><br>
其中exception_index_table指向了常量池中CONSTANT_Class_info的索引。</p>
<h2 id="linenumbertable属性">LineNumberTable属性</h2>
<p>LineNumberTable属性是用于描述Java源代码行号和字节码行号之间关系的。他不是运行时必须的，可以通过javac的参数 -g参数进行取消或生成。 如果取消这个属性，最大的影响就是在运行时抛出的异常不会包含报错行号，在调试程序时也无法根据源码行号来设置断点。</p>
<h2 id="localvariabletable和localvariabletypetable属性">LocalVariableTable和LocalVariableTypeTable属性</h2>
<p>LocalVariableTable属性是用来描述栈帧中局部变量表的变量与java源码中定义的变量之间的关系，也不是运行时必须的属性，如果不生成，最大的影响是对IDE工具调试时无法根据参数名从上下文中获取参数值。</p>
<p>在JDK5引入泛型后，LocalVariableTable属性增加了一个姐妹属性，LocalVariableTypeTable，其结构与LocalVariableTable很相似，仅仅是把描述字段的字段描述符替换成了字段的特征签名。由于描述符中泛型参数化类型被擦除，描述符不能准确描述泛型类型了，因此出现了LocalVariableTypeTable属性，使用特征签名来完成泛型的描述。</p>
<h2 id="附录-预定义属性列表">附录 预定义属性列表</h2>
<p><img src="https://gaoliang.me/post-images/1584173919837.png" alt="" loading="lazy"><br>
<img src="https://gaoliang.me/post-images/1584173926306.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM从0到1-class文件常量池]]></title>
        <id>https://gaoliang.me/post/jvm-cong-0-dao-1-class-wen-jian-chang-liang-chi/</id>
        <link href="https://gaoliang.me/post/jvm-cong-0-dao-1-class-wen-jian-chang-liang-chi/">
        </link>
        <updated>2020-03-14T04:50:34.000Z</updated>
        <content type="html"><![CDATA[<p>常量池可以比喻为class文件里的资源仓库，他是class文件结构中与其他项目关联最多的数据，通常也是占据class文件空间最大的项目。</p>
<p>由于常量池中的常量的数量是不固定的，所以在入口处需要防止一个u2类型的数据，代表常量池容量计数器。需要注意的是，这个计数器从1开始，而不是0，所以常量池计数器的值，实际表示的常量池中的常量数量+1。</p>
<p>常量池中主要存放两种常量，字面量（Literal）和符号引用（Symbolic References)。字面量比较接近Java语言层面常量的概念，而符号引用则属于编译原理方面的概念，主要包括一下几种</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Full Qualified Name）</li>
<li>字段的名称和描述（Descriptor）</li>
<li>方法的名称和描述</li>
<li>方法句柄和方法类型（Method Handle，Method Type, Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-computed Constant）<br>
Javac编译器没有连接这一个步骤，而是在虚拟机加载class文件时及逆行动态连接的，所以class文件中没有保存各个方法、字段在内存中的布局信息，这些字段、方法的引用是在虚拟机运行期间进行转换的。</li>
</ul>
<p>常量池中的每一个项目都是一个表，最初设计中只有11种，后续不断扩展，截至到JDK13，常量表中共有17中不同类型的常量。</p>
<figure data-type="image" tabindex="1"><img src="https://gaoliang.me/post-images/1584163304921.png" alt="" loading="lazy"></figure>
<p>这其中的每一种类型，都具有独立的结构，因此常量池的结构十分复杂。</p>
<h2 id="constant_utf8_info">CONSTANT_Utf8_info</h2>
<p><img src="https://gaoliang.me/post-images/1584163919336.png" alt="" loading="lazy"><br>
legth说明这这个UTF-8编码的字符串长度是多少字节，他后面紧跟着的是长度为length个字节的UTF-8缩略编码的连续数据。 UTF-8缩略编码与普通UTF-8编码的区别是：从'\u0001'到'\u007f'之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从'\u0080'到'\u07ff'之间的所有字符的缩略编码用两个字节表示，从'\u0800'开始到'\uffff'之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</p>
<p>由于class文件中方法和字段等都需要引用这个类型的常量来描述名称，所以这个常量的最大长度也就是Java中方法和字段的最大长度，u2，这也就意味着最大值为65535。所以这也意味着Java程序中变量和方法名的大小无法超过64KB。</p>
<h2 id="constant_class_info">CONSTANT_Class_info</h2>
<p><img src="https://gaoliang.me/post-images/1584169090290.png" alt="" loading="lazy"><br>
这种常量表示一个类或者接口的符号引用，其中，name_index是常量池的索引，指向一个常量池中的CONSTANT_Utf8_info类型常量，代表了这个类的全限定名。在字段表、方法表、和属性表中，会引用常量表中的符号引用来进行表达。</p>
<h2 id="其他字段结构">其他字段结构</h2>
<p><img src="https://gaoliang.me/post-images/1584169300526.png" alt="" loading="lazy"><br>
<img src="https://gaoliang.me/post-images/1584169307922.png" alt="" loading="lazy"><br>
<img src="https://gaoliang.me/post-images/1584169312061.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM从0到1-class文件结构初探]]></title>
        <id>https://gaoliang.me/post/jvm-cong-0-dao-1-class-wen-jian-jie-gou/</id>
        <link href="https://gaoliang.me/post/jvm-cong-0-dao-1-class-wen-jian-jie-gou/">
        </link>
        <updated>2020-03-13T16:07:18.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://gaoliang.me/post-images/1584115711377.png" alt="" loading="lazy"><br>
class文件是一组以8个字节为基础单位的二进制流，各个数据项紧凑排列，没有任何分隔符，当遇到需要占用8个字节以上空间的数据项时，会采用<a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html">大端原则</a>进行排列，即高位在前。</p>
<p>class文件采用了一种类似C语言结构体的伪结构来存储数据，这个伪结构中，只有两种基本的数据类型，&quot;无符号数&quot;和&quot;表&quot;。</p>
<p>无符号数属于基本数据类型，用u1，u2，u4，u8分别来表示1、2、4、8个字节的无符号数，这些无符号数可以用来描述数字、索引引用、数值量或者按照UTF-8编码构成的字符串。</p>
<p>表是由多个无符号数或其他表作为数据结构的复合数据结构，为了便于区分，这里给命名加上了后缀&quot;_info&quot;。整个class文件也可以看作是一张表。</p>
<p>无论是无符号数还是标配，当需要描述同一个类型的但是数量不定的数据时，经常会前置一个计数器。<br>
<img src="https://gaoliang.me/post-images/1584115760585.png" alt="" loading="lazy"></p>
<h2 id="魔数与class文件版本">魔数与Class文件版本</h2>
<p>class文件的魔数是 0xCAFEBABE(咖啡宝贝？?) ，有兴趣可以查一下这个数字的来历。 魔数占据了4个字节。</p>
<p>紧接着的是class文件版本号，其中第5、6个字节是次版本号，第7、8个字节是主版本号。 JDK8的版本号是0x00000034，即52.00。 大版本号随着JDK大版本的发布加1。 Java虚拟机规范要求，高版本的JDK能兼容之前版本的class文件，但强制要求不能运行以后任何版本的class文件，即使其中的内容旧版本的jdk也完全可以解析。</p>
<h2 id="常量池">常量池</h2>
<p>紧接着的两个字节，是常量池计数器(constant_pool_count)，需要注意的是，这个计数器的值和java中的习惯不同，容量计数是从1开始而不是0开始的，所以其值的大小等于常量池中的成员数+1。 class文件中，只有常量池计数器的是从1开始的。</p>
<p>常量池中主要存放两大类常量，字面量(Literal)和符号引用(Symbolic References)，字面量比较接近Java语言中常量的概念，例如文本字符串，被声明为final的常量值等。 符号引用属于编译原理方面的概念，主要包括下面几种常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Full Qualified Name）</li>
<li>字段的名称和描述（Descriptor）</li>
<li>方法的名称和描述</li>
<li>方法句柄和方法类型（Method Handle，Method Type, Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-computed Constant）</li>
</ul>
<p>Java在进行编译时，并没有C和C++的连接这个步骤，连接是在class文件加载的时候动态进行的，所以class文件不会保存各个方法和字段最终在内存中的布局，这些个字段、方法的符号引用如果不经过虚拟机的转换是无法获得真正的内存入口的。 Java虚拟机在加载类时，会从常量池中获得对应的符号引用，再在类创建时运或者运行时解析、翻译到具体的内存地址中。</p>
<p>常量池的每一项都是一个表，而且目前共有17中不同类型的常量，所以常量池是最繁琐的数据，这部分内容会在下一篇中单独介绍。</p>
<h2 id="访问标志access_flags">访问标志(access_flags)</h2>
<p>紧接着常量池的是访问标志，占用两个字节，这个标志用于识别一些类或者接口的访问信息，例如，这个class是类还是接口，是否是public，是否为abstract，是否被声明为final，是否是注解，是否是枚举，是否是非用户产生的class，是否是模块，等等。</p>
<h2 id="类索引-父类索引和接口索引集合">类索引、父类索引和接口索引集合</h2>
<p>类索引（this_class）和父类索引(super_class)都是一个u2类型的数据，接口索引集合（interfaces）则是以组u2类型的数据的集合，class文件中由着三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个父类的全限定名，接口索引集合就是用来描述这个类实现了哪些接口。</p>
<p>对于接口索引集合，入口的第一个u2类型的数据为接口计数器，表示索引表的容量。</p>
<p>通过索引的值，到常量池中查找对应类的全限定名。</p>
<h2 id="字段表集合field_info">字段表集合(field_info)</h2>
<p>字段表用于描述接口或类中声明的变量（不包括方法内部声明的局部变量）。对一个字段的描述包括，作用域（public，private，protected），是类级还是实例级变量（static），是否可变（final），并发可见性（volatile），是否可被序列化（transient修饰符），字段数据类型（基本类型、对象、数组），字段名称。 其中，各种修饰符是否存在都可以用布尔值来表示，刚好可以采用标志位的方式来存储。而字段名，字段被定义为什么类型是无法固定的，所以只能引用常量池中的常量来描述。字段表的结构如下<br>
<img src="https://gaoliang.me/post-images/1584158429668.png" alt="" loading="lazy"><br>
其中字段修饰符（access_flags）是一个u2类型的数据结构，通过标志位的方式来实现对字段修饰符是否存在的表示。<br>
<img src="https://gaoliang.me/post-images/1584158539555.png" alt="" loading="lazy"></p>
<p>access_flags后是name_index和descriptor_index，都是对常量池项的引用，分别代表字段的简单名称以及字段和方法的描述符。</p>
<p>全限定名把类全名中的<code>.</code>替换为<code>/</code>, 简单名称是指的没有类型和参数修饰符的方法或者字段名称，例如<code>inc()</code>方法和<code>m</code>字段的简单名称就是&quot;inc&quot;和&quot;m&quot;。</p>
<p>相较于简单名，方法和字段的描述符则较为复杂，描述符的作用是来描述字段的数据类型、方法的参数列表（包括数量，类型和顺序）以及返回值。 根据描述符的规定，基本数据类型(byte、char、double、float、int、long、short、boolean)以及代表无返回值的void类型都是用一个大写字符来表示，而对象类型则用字符<code>L</code>加对象的全限定名来表示。</p>
<figure data-type="image" tabindex="1"><img src="https://gaoliang.me/post-images/1584158911864.png" alt="" loading="lazy"></figure>
<p>对于数组类型，每个维度前使用一个前置的<code>[</code>来描述。</p>
<p>用描述符描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号中，然后是返回值，例如：方法<code>int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)</code>的描述符为“([CII[CIII)I”。</p>
<p>字段表结束后，还有一个属性表集合，用于存储一些额外的信息，例如果将字段m的声明改为“final static int m=123；”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。</p>
<p>字段表不会列出从父类或者父接口中继承而来的字段，但是可能会出现原本Java代码中不存在的字段，例如在内部类中为了保持对外部类的访问性，会自动添加对指向外部类实例的字段。</p>
<h2 id="方法表集合">方法表集合</h2>
<p>方法表集合和字段表集合的内容几乎一致，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（desciptor_index）、属性表集合（attributes）几项。</p>
<p>由于方法和字段修饰符的不同，所以访问标记的含义也略有不同</p>
<figure data-type="image" tabindex="2"><img src="https://gaoliang.me/post-images/1584159904681.png" alt="" loading="lazy"></figure>
<p>至此，方法的定义就可以通过访问标志、名称索引、描述符索引来表达清楚了，但是方法里面的代码去哪了呢？ 方法里的Java代码，在经过javac编译器编译为字节码指令之后，存放在方法属性表集合中的一个<code>Code</code>的属性中，属性表经常作为class文件中最具扩展性的一种数据项目。</p>
<p>与字段表集合相对应的，如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息，但同样的，也有可能会出现由编译器自动添加的方法，最常见的边是类构造器<code>&lt;clinit&gt;()</code>和实例构造器<code>&lt;init&gt;()</code>方法。</p>
<p>Java方法中，重载(Overload)一个方法，要求其简单名相同之外，害要求必须拥有一个与原方法不同的特征签名，特征签名是指一个方法中各个参数在常量池中的字符引用的集合，也正是因此，返回值不包含在特征签名中。</p>
<h2 id="属性表集合">属性表集合</h2>
<p>属性表（attribute_info）在前面的讲解中已经出现过多次，class文件、字段表、方法表都可以由自己写带的属性表集合，以描述某些场景专有的信息。虚拟机规范对属性表的限制稍微宽松一些，不要求各个属性具有严格顺序，而且只要不与已有属性崇明，任何人实现的编译其都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时，会忽略它不认识的属性。</p>
<p>对于每一个属性，他的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构是完全自定义的，只需要通过一个u4长度属性来表明属性值所占用的位数即可。<br>
<img src="https://gaoliang.me/post-images/1584160830127.png" alt="" loading="lazy"></p>
<p>对于属性表详细的解释，会在下一篇中进行介绍。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM从0到1-内存划分]]></title>
        <id>https://gaoliang.me/post/jvm-cong-0-dao-1-nei-cun-guan-li/</id>
        <link href="https://gaoliang.me/post/jvm-cong-0-dao-1-nei-cun-guan-li/">
        </link>
        <updated>2020-03-13T15:10:49.000Z</updated>
        <content type="html"><![CDATA[<p>jvm运行时会把内存分为多个数据区域，根据《java虚拟机规范》规定，可以划分为方法区，堆，虚拟机栈，本地方法栈和程序计数器，其中方法区和堆是所有线程所共享的，其他则是每个线程隔离的。<br>
<img src="https://gaoliang.me/post-images/1584113372648.png" alt="" loading="lazy"></p>
<h2 id="程序计数器">程序计数器</h2>
<p>其中记录的是当前所执行的字节码的行号，字节码解释就是通过改变这个计数器来完成包括分支、跳转、循环、异常、线程恢复等基本功能的。当线程执行的是 本地方法时，这个计数器的值为空。 这个区域是《java虚拟机规范》中唯一一个没有规定OOM情况的区域。</p>
<h2 id="java虚拟机栈">Java虚拟机栈</h2>
<p>每个Java方法被执行时，虚拟机都会同步创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，一个方法被调用到执行结束的过程，也就对应着栈帧从入栈到出栈的过程。</p>
<p>《java虚拟机规范》规定这个区域会存在两种一场，栈深度大于虚拟机允许深度时，抛出StackOverFlowError，如果栈容量可以动态扩展，则当无法扩展时，抛出OOM异常。我们常用的HotSpot虚拟机栈容量是不会动态扩展的，但是这并不意味着就不会抛出OOM异常，如果线程申请栈空间失败了，也是会抛出OOM的。</p>
<h2 id="本地方法栈">本地方法栈</h2>
<p>和Java虚拟机栈类似，只是执行的是本地方法，虚拟机规范没有堆这一部分有强制规定，有些虚拟机（例如HotSpot直接把Java虚拟机栈和本地方法栈合并了）</p>
<h2 id="java堆">Java堆</h2>
<p>堆的唯一目的就是存放对象实例。其内部结构并没有进一步的细致划分，我们常说的新生代，老年代，永久代，Eden，Survivor等都是一部分垃圾收集器的设计风格，和虚拟机规范乃至虚拟机实现没有关系。</p>
<p>从分配对象的角度看，所有线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）用于提升对象分配的效率。 当Java堆中没有空间完成实例分配，而且堆的大小也没法继续扩展时，虚拟机会抛出OOM异常。</p>
<h2 id="方法区">方法区</h2>
<p>方法区和堆一样，也是各个线程共享的内存区域，这个区域用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器（JIT）编译后的代码缓存等数据。Java虚拟机规范中，把方法区描述为堆的一个逻辑部分，但是他取有一个别名“非堆”（Non-Heap）。<br>
说到方法区，就要提到“永久代”的概念，在JDK8以前，由于HotSpot虚拟机的流行，很多人直接把方法区称之为“永久代”，这种说法是错误的，仅仅是因为在当时HotSpot设计选择把垃圾回收分代的设计扩展到了方法区，或者说，是使用“永久代”来实现了方法区。 原则上，如何设计和实现方法区，Java虚拟机规范并没有要求。在JDK8时，HotSpot虚拟机已经完全抛弃了永久代的概念，改用在本地内存中实现的原空间（Meta Space）来代替。<br>
Java虚拟机规范要求，当方法去无法满足新内存分配需求的时候，会抛出OOM</p>
<h3 id="运行时常量池">运行时常量池</h3>
<p>运行时常量池是方法区的一部分，Class文件中，除了类的版本、字段、方法、接口等描述信息外，还有一项是常量池表，用于存放在编译期间产生的各种字面量和符号引用，这部分内容会在类加载后存放到方法区的运行时常量池中。 Java虚拟机规范堆class文件的每个部分的格式都有要求，例如每个字节用于存储什么数据。 但是，对于运行时常量池，规范并没有给出细节的要求，所以不同的虚拟机实现会按照自己的设计来实现这个区域，一般来说，除了保存Class文件中的符号引用外，还会把由符号引用翻译而来的直接引用也存储到这个运行时常量池中来。</p>
<p>运行时常量池的一个特点是具有动态性，并不要求常量必须在编译期产生，所以并非只有class文件常量池中的内容可以放入运行时常量池，也可以在运行期间放入新的常量，例如String类的intern()方法。</p>
<h2 id="直接内存">直接内存</h2>
<p>首先要注意，直接内存并不属于虚拟机运行时数据区的一部分，也不是虚拟机规范规定的内存区域，但是这一部分也会被频繁使用，也有可能导致OOM。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 日志系统梳理]]></title>
        <id>https://gaoliang.me/post/java-ri-zhi-xi-tong-shu-li/</id>
        <link href="https://gaoliang.me/post/java-ri-zhi-xi-tong-shu-li/">
        </link>
        <updated>2019-10-19T07:36:28.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://gaoliang.me/post-images/1571471023093.png" alt="slf4j 桥接传统日志系统" loading="lazy"><br>
<img src="https://gaoliang.me/post-images/1571471220440.png" alt="slf4j 桥接传统日志系统" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理软件的代理模式介绍]]></title>
        <id>https://gaoliang.me/post/ssr-v2ray-proxy-analysis/</id>
        <link href="https://gaoliang.me/post/ssr-v2ray-proxy-analysis/">
        </link>
        <updated>2019-09-10T08:47:51.000Z</updated>
        <content type="html"><![CDATA[<p>常用的代理软件，通常会有系统代理模式、PAC、代理规则等多项设置，这些设置通常都十分相近，容易混淆，所以做一次简单的梳理。<br>
ssr-csharp，shadowsocks-windows<br>
这两个 windows 软件，通常在右键菜单里会有<code>系统代理模式</code>、<code>PAC</code>、<code>代理规则</code>，三个关系到一个 url 是否会走代理的配置，为了搞清楚他们之间的关系，我们需要先知道系统代理和 PAC 是什么</p>
<ol>
<li>系统代理<br>
一个操作系统，无论是 Windows、macOS、Linux 各个发型版本，都会有对应的系统级代理设置功能，这个设置是对所有运行在操作系统上的软件公开的，所有的软件都可以知道当前是否有系统代理可用，自己是否要使用系统代理。<br>
例如，在 c# 中<pre><code class="language-c#">public static System.Net.IWebProxy GetSystemWebProxy();
</code></pre>
</li>
</ol>
<p>在我们常用的浏览器中，浏览器类的软件，通常都是默认如果你设置了系统代理，就会通过系统代理来访问外部网络，例如 Chrome、Firefox 等，都有这样的机制。 而其他的软件，通常也会设计自己的代理策略，例如走系统代理，不走系统代理，或者支持用户设置。 例如，下图中 Docker 的 macOS 客户端中，支持设置使用系统代理，但是不支持用户设置为不使用代理。<br>
<img src="https://gaoliang.me/post-images/1568105455649.png" alt="Docker上的代理设置界面" loading="lazy"><br>
另外，在早期版本的 windows 上，经常会看到一些软件代理设置中，有<code>使用 IE 代理</code>的选项，这是因为早期版本的 Windows，IE 代理设置和系统代理设置是同步的，IE 代理就是系统代理。目前新版本的 Windows 已经不再集成 IE, 所以 大部分软件现在都该叫系统代理设置了。例如下图早期版本的迅雷代理设置截图。<br>
<img src="https://gaoliang.me/post-images/1568105326854.png" alt="早期版本的迅雷设置界面" loading="lazy"><br>
2. PAC<br>
要说 PAC，我们就要先了解代理有哪些模式。 打开 macOS 的代理配置界面，可以看到，有多种代理协议可选，常用的包括 HTTP，SOCKS5 等。如果我们设置 HTTP 或者 SOCKS5 代理，那么启用系统代理的应用，就会将所有的请求全部转发到这个代理服务器，通过代理服务器进行访问。通常这对应着我们的 ssr 客户端里的<code>系统代理模式-&gt; 全局模式</code>,这种模式下，使用系统代理的软件，所有的网络请求就全部会通过系统代理设置的代理服务器。</p>
<p>接下来说 PAC，PAC 是 Proxy Auto-Config 的简写，系统代理可以选用这种模式。 PAC 的意思是代理自动配置，作用是是根据用户请求的地址，决定使用哪个代理服务器，PAC 通常是一个 js 脚本。 这个模式就对应 ssr <code>系统代理模式-&gt; PAC 模式</code> 在 Windows 的 ssr 客户端上，一般还支持设置不通的 PAC 规则， 例如<code>跳过局域网</code>，<code>跳过局域网和大陆IP</code>等，这些功能其实都是通过修改 PAC 的 js 脚本来实现的。<br>
<img src="https://gaoliang.me/post-images/1568106773345.png" alt="PAC 代理设置" loading="lazy"></p>
<p>知道了系统代理和 PAC 的概念之后，我们来看下 Windows 里面 ssr 客户端的设置<br>
<code>系统代理模式-直连</code>：顾名思义，不设置任何系统代理，直接连接，不通过代理服务器。<br>
<code>系统代理模式-全局</code>：全局模式会设置系统代理的 socks5 代理，所有使用系统代理的软件的所有请求，都会通过设置的代理服务器。<br>
<code>系统代理模式-PAC</code>：设置系统代理走 PAC 模式，使用系统代理的软件发出的请求，会通过 PAC 进行自动代理切换。</p>
<p>未完待续...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我与我的利器]]></title>
        <id>https://gaoliang.me/post/talking-about-me-and-my-favorite-toolset/</id>
        <link href="https://gaoliang.me/post/talking-about-me-and-my-favorite-toolset/">
        </link>
        <updated>2019-07-26T10:11:17.000Z</updated>
        <content type="html"><![CDATA[<p>从 <a href="http://gridea.dev">Gridea</a>（一个静态博客写作客户端）作者<a href="https://fehey.com">海岛心hey</a>的博客看到<a href="https://liqi.io/community/">利器社群计划</a>后，感觉很有意思，自己也写了一篇，但是说来惭愧，自己算不上创造者，没有什么拿的出手的作品，就单纯的分享下自己的一些内容吧，当作本博客的「关于」也好。</p>
<p>更新记录：</p>
<blockquote>
<ul>
<li>2020 年 1 月 15 日：过年了过年了</li>
<li>2019 年 9 月 17 日：更新一波</li>
<li>2019 年 8 月 23 日：有工位了，更新一波</li>
<li>2019 年 7 月 26 日：参加工作一个月，本文创建</li>
</ul>
</blockquote>
<h2 id="介绍一下你自己和所做的工作">介绍一下你自己和所做的工作。</h2>
<p>后端程序猿一只，刚参加工作，工作中主要使用 Java，自己写玩具一般用 Python + Vue。</p>
<h2 id="你的职业生涯的转折点是什么">你的职业生涯的转折点是什么？</h2>
<p>大学阴差阳错被调剂到应用物理专业，好在大一加入了学校的技术社团，接触到了 Linux、前后端的一些概念，决定转专业到计算机，后成功。大二大三整个人浑浑噩噩，不知道在做什么，似乎什么都接触了一些，但是似乎又什么都没深入。 稀里糊涂就到了大三下，别人都在找实习或者考研，自己思考了很久好后决定找工作，方向就是自己一直比较感兴趣的后端开发。 至此，自己的职业生涯开始了</p>
<h2 id="你都在使用哪些硬件">你都在使用哪些硬件？</h2>
<ul>
<li><strong><a href="https://item.jd.com/5456134.html">小米笔记本Pro 16+256</a></strong>：搭配黑果小兵的<a href="https://github.com/daliansky/XiaoMi-Pro-Hackintosh">黑苹果 EFI</a>，使用体验很完美，<s>准备等啥时候苹果改掉愚蠢的蝴蝶键盘再洗白（主要是没钱</s> 单纯是没钱</li>
<li><strong><a href="https://www.lg.com/cn/monitors/lg-27UL650">LG 27UL650 4K显示器</a></strong>: 槽点是只有一个 dp 口，没有 usb hub</li>
<li><strong><a href="https://www.apple.com/cn/iphone-xr/specs/">iPhone XR 64G</a></strong>：咸鱼入手<br>
<s><strong><a href="https://www.mi.com/mi6/">小米6 64G</a></strong>：也算是一代神机了，835 + 6G，性能还没遇到啥问题</s></li>
<li><strong><a href="http://consumer.panasonic.cn/product/cameras-camcorders/lumix-series/lumix-g-series/dmc-gx85.html">松下 GX85 + 松下 25 f1.7 + 松下 14-42A</a></strong>：闲鱼收的，还在摸索</li>
<li><strong><a href="https://www.bose.cn/zh_cn/products/headphones/over_ear_headphones/quietcomfort-35-wireless-ii.html">Bose QC35 I</a></strong>：一代 QC35，电源键有小毛病但不影响使用</li>
<li><strong><a href="https://www.apple.com/cn/airpods/">Airpods 2 有线充电版</a></strong>：几乎找不到缺点</li>
<li><strong><a href="https://2.taobao.com">斐讯 K2P A1</a></strong>：当年前几批车上的，顺利下车并刷上老毛子固件，放在自如出租屋美滋滋</li>
<li><strong><a href="https://www.pinduoduo.com/">斐讯 M1 空气检测仪</a></strong>：斐讯遗产，甲醛传感器还不错，颜值也不错，路由器改 dnsmasq 后可以接入 homeassistant 和 homekit。 另外提醒住自如的各位务必注意空气质量</li>
<li><strong><a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/">树莓派3B</a></strong>：在角落里默默吃灰的树莓派，只部署了 homeassistant</li>
<li><strong><a href="https://www.mi.com/aispeaker/">小爱音响</a></strong> 配合 <strong><a href="https://item.mi.com/1191800001.html">米家空调伴侣</a></strong>：智能家居缺个家，那就先让自如的空调变智能</li>
<li><strong><a href="https://item.jd.com/3491196.html">IKBC C87 键盘</a></strong>：大二买的键盘，质量不错，一只在用。</li>
</ul>
<h2 id="软件呢">软件呢？</h2>
<h3 id="macos-gui软件">macOS GUI软件</h3>
<ul>
<li><strong><a href="https://www.alfredapp.com/">Alfred3</a></strong>：snippets，剪切板，自定义 workflow，爽得很。 另外最近出 Alfred4 了，看了下似乎没啥提升，所以没升级（主要还是没钱</li>
<li><strong><a href="https://www.proxifier.com/">Proxifier</a></strong>：把 v2，ss 之类的 socks5 代理转换为全局代理，可自定规则，用来加速 git，npm，brew 之流再好不过了，免去配置镜像站的麻烦</li>
<li><strong><a href="https://1password.com/">1Password 7</a></strong>：保存所有的账号密码、二步验证码等，体验很不错</li>
<li><strong><a href="https://github.com/Caldis/Mos">Mos</a></strong>：一个用于在 MacOS 上平滑你的鼠标滚动效果或单独设置滚动方向的小工具, 让你的滚轮爽如触控板</li>
<li><strong><a href="https://iina.io/">IINA</a></strong>：大概是 macOS 上最好用的视频播放器了吧，同时又那么好看，找不到拒绝的理由</li>
<li><strong><a href="https://bjango.com/mac/istatmenus/">iStat Menus</a></strong> 在菜单栏监控你的电脑状态，满足强迫症的一切要求</li>
<li><strong><a href="https://www.jetbrains.com/">JetBrains 全家桶</a></strong>：主力开发工具，IDEA、PyCharm 都是我的老朋友</li>
<li><strong><a href="http://Gridea.dev">Gridea</a></strong>：一个静态博客写作客户端，界面很漂亮，并且支持三个平台。 本博客就是基于此构建</li>
<li><strong><a href="https://code.visualstudio.com/">VS Code</a></strong>：偶尔写前端时用，速度快</li>
<li><strong><a href="https://www.jetbrains.com/">JetBrains 全家桶</a></strong>：主力开发工具，IDEA、PyCharm 都是我的老朋友</li>
</ul>
<h3 id="终端软件">终端软件</h3>
<ul>
<li><strong><a href="https://www.iterm2.com/">iTerm2</a></strong> 配合 <strong><a href="https://ohmyz.sh/">oh-my-zsh</a></strong>：替代 macOS 自带终端，zsh 用起来也很比 bash 要舒服，听说最新的 macOS 10.15 已经默认用 zsh 了</li>
<li><strong><a href="https://www.mycli.net/">mycli</a></strong>：支持语法高亮和自动补全的 MySQL cli，很好用</li>
</ul>
<h3 id="移动端软件">移动端软件</h3>
<ul>
<li><strong><a href="https://apps.apple.com/cn/app/%E7%86%8A%E7%8C%AB%E5%90%83%E7%9F%AD%E4%BF%A1-%E9%98%B2%E9%AA%9A%E6%89%B0/id1319191852">熊猫吃短信</a></strong>：吃垃圾短信的</li>
<li><strong><a href="https://apps.apple.com/tw/app/shadowrocket/id932747118">ShadowRocket</a></strong>：你懂的</li>
</ul>
<h2 id="你最理想的工作环境是什么">你最理想的工作环境是什么？</h2>
<ul>
<li>成为一名独立开发者，面向自己的产品和乐趣开发，而不是面向工资开发</li>
<li>不需要通勤</li>
<li>足够优秀的网络</li>
<li>空气要好，因为我被自如的甲醛吓怕了</li>
</ul>
<h2 id="你平时获得工作灵感的方式有哪些">你平时获得工作灵感的方式有哪些？</h2>
<ul>
<li>和朋友的吐槽。平常经常和朋友吐槽各种产品和技术，从中发现了不少问题，也产生了很多灵感（虽然真的去做的不多。。</li>
<li>逛 GitHub 和 V2EX 等程序猿大量聚集的论坛和社区，往往能发现新的技术</li>
<li>YouTube 上有大量干货和技术分享</li>
</ul>
<h2 id="推荐一件生活中的利器给大家">推荐一件生活中的利器给大家。</h2>
<p><a href="https://docs.rsshub.app/">RSSHub</a> 是一个轻量、易于扩展的 RSS 生成器, 可以给任何奇奇怪怪的内容生成 RSS 订阅源。<br>
搭配 Telegram 的 RSSBot 机器人，可以做到很多消息的主动推送，减少信息分散的负担。</p>
<blockquote>
<p>本文参与了「利器社群计划」，发现更多创造者和他们的工具：https://liqi.io/community/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java学习-类]]></title>
        <id>https://gaoliang.me/post/java-class-learn/</id>
        <link href="https://gaoliang.me/post/java-class-learn/">
        </link>
        <updated>2018-04-24T02:06:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-实现一个类">1. 实现一个类</h2>
<p>定义一个完整类的格式应该是</p>
<p>[类访问修饰符] [修饰符] 类名 [extend 父类名] [implements 接口列表]{<br>
...<br>
}</p>
<pre><code class="language-java">public class Employee{
    private String name;
    private double salary;
    ... 
}
</code></pre>
<p>类访问修饰符：</p>
<table>
<thead>
<tr>
<th>类访问修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可以被所有类访问，注意public类的所在的文件名应该与该类名相同,一个java文件至多有一个public类</td>
</tr>
<tr>
<td>package (缺省)</td>
<td>仅能被相同包中的类访问，缺省的值</td>
</tr>
</tbody>
</table>
<p>修饰符:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>使用此修饰符的类不能被继承</td>
<td></td>
</tr>
<tr>
<td>abstract</td>
<td>声明这个类是一个抽象类</td>
<td>含有抽象方法的类必须声明为抽象类，但是抽象类不一定含有抽象方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Python对比：Python由于鸭子类型的存在，很少使用接口和抽象类，但在需要使用时，可以使用ABCMeta元类和abstractmethod装饰器来实现,参考<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p12_define_interface_or_abstract_base_class.html">Python3 Cookbook</a></p>
</blockquote>
<h2 id="2-类中的成员">2. 类中的成员</h2>
<p>Java 类中的成员可以为变量、方法、构造器和初始化块。</p>
<h3 id="实例成员和类成员静态成员">实例成员和类成员(静态成员)</h3>
<p>Java 类中的成员分为实例成员和类成员, 没有加 static 修饰符的成员为实例成员，加了 static 修饰符的成员为类成员,或者说静态成员，构造方法不能被 static 修饰。</p>
<pre><code class="language-java">public class Employee{
    private int id; // 实例变量
    private static int last_id; // 类变量

    static { // 静态初始化块
        last_id = 0;
    }

    Employee(){ // 构造方法
        last_id += 1;
        this.id = last_id;
    }

    // 实例方法
    public int get_id(){
        return this.id;
    }

    // 类方法
    public static int get_last_id(){
        return last_id;
    }
}
</code></pre>
<p>需要注意，静态方法不能访问实例成员，可以在实例上调用静态方法。 静态方法常用于工厂模式，关于初始化块的内容会在后面介绍。</p>
<blockquote>
<p>Python对比：Python中也有实例成员和类成员，其中类变量和实例变量与Java中基本类似，但是Python中静态方法和类方法是两种不同的方法类型，分别用<code>@staticmethod</code> 和 <code>@classmethod</code>装饰器装饰，<code>@classmethod</code>装饰的类方法更接近与Java中的类方法，因为其能够访问到类中定义的其他类成员。上述代码的Python实现如下:</p>
</blockquote>
<pre><code class="language-python">class Employee:
    last_id  = 0

    def __init__(self):
        # (self.类变量名)只能用来访问类变量
        # 修改时必须用(类名.变量名)
        # 否则会导致类变量变成实例变量
        Employee.last_id +=1
        self.id = self.last_id
    
    def get_id(self):
        return self.id
    
    @classmethod
    def get_last_id(cls):
        return cls.last_id

</code></pre>
<h3 id="成员的访问修饰符">成员的访问修饰符</h3>
<p>Java 中可以对类中的成员使用访问修饰符，Java 支持四中成员访问修饰符，对应的访问等级如下， 注意其与类访问修饰符的联系。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>子孙类</th>
<th>其他包</th>
<th>其他包子孙类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y/N（说明）</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>public</code>: 公用访问修饰符， 其修饰的成员可以被任何其他类访问，所有的公有成员都可以被子类继承。</p>
</li>
<li>
<p><code>protect</code>: 受保护的访问修饰符，相较于 public，其修饰的成员不能被其他包中的非子孙类访问，对于子孙类，要分为同包子孙类和非同包子孙类分析。 对于同包子孙类，所有 procted 的成员都可以被访问； 对于非同包的子孙类，较为复杂，可以参考<a href="http://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html">Java protected 关键字详解<br>
</a>。</p>
</li>
<li>
<p><code>default</code>: 默认访问修饰符，可以被当前类和同一包内的其他类访问。</p>
</li>
<li>
<p><code>private</code>: 私有访问修饰符，最严格的访问修饰符，只能被当前类访问。</p>
</li>
</ul>
<h3 id="final和static修饰符">final和static修饰符</h3>
<p>static 修饰符在前面已经学习过了，用来定义类级成员。 而 final 修饰符在学习类修饰符时也有提到，被 final 修饰的类不能被继承，其修饰修饰变量和修饰方法时，作用也是类似的。</p>
<p>final修饰的变量： 表示常量，只能被赋值一次，不能被修改。final 修饰的方法：不能被子类覆盖，但是可以被子类继承。</p>
<h3 id="初始化块">初始化块</h3>
<p>初始化块可以分为普通的初始化块和静态初始化块</p>
<p>普通初始化块： 从某种程度上来说，是构造函数的补充。</p>
<ul>
<li>普通初始化块总是在构造函数之前执行</li>
<li>与构造函数相比，他不接受任何参数。</li>
<li>一般的使用场景是需要初始化的内容不需要任何参数时，可以提取到初始化块中执行，比如多个构造器中的相同代码可以提取到初始化快中，提高初始化代码的复用。</li>
</ul>
<p>静态初始化块：</p>
<ul>
<li>在类初始化的阶段调用静态初始化块，而不是创建对象时，因此<strong>总是比普通初始化块要早执行</strong></li>
<li>只能对静态成员进行初始化，而不能对实例成员进行初始化。</li>
<li>只能访问静态成员。</li>
</ul>
<h3 id="构造器与this">构造器与this</h3>
<p>构造器是类中的一个特殊的方法，要求其方法名与类名相同，并且不返回然和类型。 其访问修饰符默认是 public 的。 如果指定了其返回值，该方法就只是一个普通方法。</p>
<p>构造器可以重载，可以使用this语句访问类中的其他实例成员，也可以用 this() 方法访问其他的重载的构造器。</p>
<h2 id="包的使用">包的使用</h2>
<p>要把一个类放到包中，需要将包的声明作为源文件的第一个声明。<br>
如</p>
<pre><code class="language-java">package com.gaoliang.learn_java;

public class Employee{
    ...
}
</code></pre>
<p>如果子目录和包的声明相同，即com/gaoliang/learn_java/Employee.java,则执行</p>
<pre><code class="language-bash">javac com/gaoliang/learn/Employee.java
</code></pre>
<p>会在对应的目录产生class文件，然后可以通过全限定的类名运行程序</p>
<pre><code class="language-bash">java com.gaoliang.learn.Employee
</code></pre>
<h3 id="类路径">类路径</h3>
<p>可以把class文件放到一个或者多个JAR文件中，</p>
<pre><code>jar cvf library.jar /path/to/*.class ...
</code></pre>
<p>如果要试用这些jar文件，则需要通过class path告诉编译器和虚拟机jar文件的位置。class path可以包含</p>
<ul>
<li>包含class文件的目录（包含匹配包名的子目录）</li>
<li>JAR文件</li>
<li>包含JAR文件的目录</li>
</ul>
<p>javac和java命令都有-classpath参数，可以缩写成 -cp，例如</p>
<pre><code class="language-bash">java -cp .:../libs/lib1.jar:../libs/lib2.jar com.mycompany.Mainclass
</code></pre>
<h3 id="导入包">导入包</h3>
<h4 id="import语句">import语句</h4>
<p>import语句可以使用户无需使用全限定名的使用类，例如</p>
<pre><code class="language-java">import java.util.Random;
Random random =  new Random()
</code></pre>
<p>可以使用通配符一次导入一个包中的所有类</p>
<pre><code class="language-java">import java.util.*;
</code></pre>
<p>但是要注意的是通配符只能用来导入类，不能通配的导入包。<br>
如果出现类名称冲突，需要手动导入自己想要的具体类，手动解决冲突。</p>
<h4 id="静态导入">静态导入</h4>
<p>静态导入使用户可以以 import 声明的形式导入静态的方法和变量，例如</p>
<pre><code class="language-java">import static java.lang.Math.*;
sqrt(12);
</code></pre>
<p><code>sqrt</code>是 Math 类的一个静态方法，可以用<code>import static</code>直接导入。</p>
<h3 id="嵌套类">嵌套类</h3>
<p>除了将类组织成包，还可以将一个类定义在另一个类的内部。 这样的类称为嵌套类。</p>
<h4 id="静态嵌套类">静态嵌套类</h4>
<p>首先看一个例子</p>
<pre><code class="language-java">public class Order{

    private static class Item{
        String description;
        int quality;
        double unitPrice;
        double price() {return quantity * unitPrice;}
    }
    
    private ArrayList&lt;Item&gt; items = new ArrayList&lt;&gt;();
    ...
}
</code></pre>
<p>这个例子中的 Item 是一个静态嵌套类，由于其使用 private 进行修饰，所以只有Order 类能够使用该类，如果使用 public 进行修饰，由于同时还是一个 static 的类， 所以可以被其他类在外部通过 Order.Item 进行使用。 所以静态嵌套类更像是为一个类增加了一个命名空间，更明显的表示Item是专属与 Order 的，而对于Order 和 Item 来说，两者并没有直接的关系。</p>
<h4 id="内部类">内部类</h4>
<p>如果去掉 static 修饰，那么这个嵌套类就变成了内部类。 内部类与静态嵌套类的最大区别是内部类可以获知自己所属的外部类实例。</p>
<pre><code class="language-java">import java.util.ArrayList;

public class ClassRoom {

    public class Student {
        String name;
        int age;

        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }
        // 注意这里，student是可以获取外部类的引用的
        // 所以可以使用外部类的变量和方法，比如这里的students
        public void leave() {
            students.remove(this);
            // 也可以写成这样，ClassRoom.this就是外部类实例的引用。
            // ClassRoom.this.students.remove(this);
        }
    }

    private ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();

    public Student enroll(String name, int age) {
        Student newStudent = new Student(name, age);
        // 其实是 Student newStudent  = this.new Student(name, age)
        students.add(newStudent);
        return newStudent;
    }
}
</code></pre>
<p>去掉了 static， 出现了本质区别， 此时的 Student 类是知道自己所属于的 ClassRoom 实例的，并且可以使用<code>OutClass.this</code>获取外部类实例的引用。</p>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gaoliang.me</id>
    <title>高亮的杂货铺</title>
    <updated>2019-07-26T10:15:02.818Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gaoliang.me"/>
    <link rel="self" href="https://gaoliang.me/atom.xml"/>
    <subtitle>Happy coding!</subtitle>
    <logo>https://gaoliang.me/images/avatar.png</logo>
    <icon>https://gaoliang.me/favicon.ico</icon>
    <rights>All rights reserved 2019, 高亮的杂货铺</rights>
    <entry>
        <title type="html"><![CDATA[我与我的利器]]></title>
        <id>https://gaoliang.me/post/talking-about-me-and-my-favorite-toolset</id>
        <link href="https://gaoliang.me/post/talking-about-me-and-my-favorite-toolset">
        </link>
        <updated>2019-07-26T10:11:17.000Z</updated>
        <content type="html"><![CDATA[<p>从 <a href="http://gridea.dev">Gridea</a>（一个静态博客写作客户端）作者<a href="https://fehey.com">海岛心hey</a>的博客看到<a href="https://liqi.io/community/">利器社群计划</a>后，感觉很有意思，自己也写了一篇，但是说来惭愧，自己算不上创造者，没有什么拿的出手的作品，就单纯的分享下自己的一些内容吧，当作本博客的「关于」也好。</p>
<p>更新记录：</p>
<blockquote>
<ul>
<li>2019年7月26日： 参加工作一个月，本文创建</li>
</ul>
</blockquote>
<h2 id="介绍一下你自己和所做的工作">介绍一下你自己和所做的工作。</h2>
<p>后端程序猿一只，刚参加工作，工作中主要使用 Java，自己写玩具一般用 Python + Vue。</p>
<h2 id="你的职业生涯的转折点是什么">你的职业生涯的转折点是什么？</h2>
<p>大学阴差阳错被调剂到应用物理专业，好在大一加入了学校的技术社团，接触到了 Linux、前后端的一些概念，决定转专业到计算机，后成功。大二大三整个人浑浑噩噩，不知道在做什么，似乎什么都接触了一些，但是似乎又什么都没深入。 稀里糊涂就到了大三下，别人都在找实习或者考研，自己思考了很久好后决定找工作，方向就是自己一直比较感兴趣的后端开发。 至此，自己的职业生涯开始了</p>
<h2 id="你都在使用哪些硬件">你都在使用哪些硬件？</h2>
<ul>
<li><strong><a href="https://item.jd.com/5456134.html">小米笔记本Pro 16+256</a></strong>：搭配黑果小兵的<a href="https://github.com/daliansky/XiaoMi-Pro-Hackintosh">黑苹果 EFI</a>，使用体验很完美，准备等啥时候苹果改掉愚蠢的蝴蝶键盘再洗白（主要是没钱</li>
<li><strong><a href="https://item.jd.com/3133825.html">iPhone 7 128G</a></strong>：电池效率 83% 了，每天插着线续命</li>
<li><strong><a href="https://www.mi.com/mi6/">小米6 64G</a></strong>：也算是一代神机了，835 + 6G，性能还没遇到啥问题</li>
<li><strong><a href="https://www.bose.cn/zh_cn/products/headphones/over_ear_headphones/quietcomfort-35-wireless-ii.html">Bose QC35 I</a></strong>：一代 QC35，电源键有小毛病但不影响使用</li>
<li><strong><a href="https://2.taobao.com">斐讯 K2P A1</a></strong>：当年前几批车上的，顺利下车并刷上老毛子固件，放在自如出租屋美滋滋</li>
<li><strong><a href="https://www.pinduoduo.com/">斐讯 M1 空气检测仪</a></strong>：斐讯遗产，甲醛传感器还不错，颜值也不错，路由器改 dnsmasq 后可以接入 homeassistant 和 homekit。 另外提醒住自如的各位务必注意空气质量</li>
<li><strong><a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/">树莓派3B</a></strong>：在角落里默默吃灰的树莓派，只部署了 homeassistant</li>
<li><strong><a href="https://www.mi.com/aispeaker/">小爱音响</a></strong> 配合 <strong><a href="https://item.mi.com/1191800001.html">米家空调伴侣</a></strong>：智能家居缺个家，那就先让自如的空调变智能</li>
<li><strong><a href="https://item.jd.com/3491196.html">IKBC C87 键盘</a></strong>：大二买的键盘，质量不错，一只在用。</li>
</ul>
<h2 id="软件呢">软件呢？</h2>
<h3 id="macos-gui软件">macOS GUI软件</h3>
<ul>
<li><strong><a href="https://www.alfredapp.com/">Alfred3</a></strong>：snippets，剪切板，自定义 workflow，爽得很。 另外最近出 Alfred4 了，看了下似乎没啥提升，所以没升级（主要还是没钱</li>
<li><strong><a href="https://www.proxifier.com/">Proxifier</a></strong>：把 v2，ss 之类的 socks5 代理转换为全局代理，可自定规则，用来加速 git，npm，brew 之流再好不过了，免去配置镜像站的麻烦</li>
<li><strong><a href="https://github.com/Caldis/Mos">Mos</a></strong>：一个用于在 MacOS 上平滑你的鼠标滚动效果或单独设置滚动方向的小工具, 让你的滚轮爽如触控板</li>
<li><strong><a href="https://iina.io/">IINA</a></strong>：大概是 macOS 上最好用的视频播放器了吧，同时又那么好看，找不到拒绝的理由</li>
<li><strong><a href="https://bjango.com/mac/istatmenus/">iStat Menus</a></strong> 在菜单栏监控你的电脑状态</li>
<li><strong><a href="https://www.jetbrains.com/">JetBrains 全家桶</a></strong>：主力开发工具，IDEA、PyCharm 都是我的老朋友</li>
<li><strong><a href="http://Gridea.dev">Gridea</a></strong>：一个静态博客写作客户端，界面很漂亮，并且支持三个平台。 本博客就是基于此构建</li>
<li><strong><a href="https://code.visualstudio.com/">VS Code</a></strong>：偶尔写前端时用，速度快</li>
<li><strong><a href="https://www.jetbrains.com/">JetBrains 全家桶</a></strong>：主力开发工具，IDEA、PyCharm 都是我的老朋友</li>
</ul>
<h3 id="终端软件">终端软件</h3>
<ul>
<li><strong><a href="https://www.iterm2.com/">iTerm2</a></strong> 配合 <strong><a href="https://ohmyz.sh/">oh-my-zsh</a></strong>：替代 macOS 自带终端，zsh 用起来也很比 bash 要舒服，听说最新的 macOS 10.15 已经默认用 zsh 了</li>
<li><strong><a href="https://www.mycli.net/">mycli</a></strong>：支持语法高亮和自动补全的 MySQL cli，很好用</li>
</ul>
<h3 id="移动端软件">移动端软件</h3>
<ul>
<li><strong><a href="https://apps.apple.com/cn/app/%E7%86%8A%E7%8C%AB%E5%90%83%E7%9F%AD%E4%BF%A1-%E9%98%B2%E9%AA%9A%E6%89%B0/id1319191852">熊猫吃短信</a></strong>：吃垃圾短信的</li>
<li><strong><a href="https://apps.apple.com/tw/app/shadowrocket/id932747118">ShadowRocket</a></strong>：你懂的</li>
</ul>
<h2 id="你最理想的工作环境是什么">你最理想的工作环境是什么？</h2>
<ul>
<li>成为一名独立开发者，面向自己的产品和乐趣开发，而不是面向工资开发</li>
<li>不需要通勤</li>
<li>足够优秀的网络</li>
<li>空气要好，因为我被自如的甲醛吓怕了</li>
<li>一个视野好的大桌子，入职以来公司工位不足🙄，至今还在和同事拼桌</li>
</ul>
<h2 id="你平时获得工作灵感的方式有哪些">你平时获得工作灵感的方式有哪些？</h2>
<ul>
<li>和朋友的吐槽。平常经常和朋友吐槽各种产品和技术，从中发现了不少问题，也产生了很多灵感（虽然真的去做的不多。。</li>
<li>逛 GitHub 和 V2EX 等程序猿大量聚集的论坛和社区，往往能发现新的技术</li>
<li>YouTube 上有大量干货和技术分享</li>
</ul>
<h2 id="推荐一件生活中的利器给大家">推荐一件生活中的利器给大家。</h2>
<p><a href="https://docs.rsshub.app/">RSSHub</a> 是一个轻量、易于扩展的 RSS 生成器, 可以给任何奇奇怪怪的内容生成 RSS 订阅源。<br>
搭配 Telegram 的 RSSBot 机器人，可以做到很多消息的主动推送，减少信息分散的负担。</p>
<blockquote>
<p>本文参与了「利器社群计划」，发现更多创造者和他们的工具：https://liqi.io/community/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java学习-类]]></title>
        <id>https://gaoliang.me/post/java-class-learn</id>
        <link href="https://gaoliang.me/post/java-class-learn">
        </link>
        <updated>2018-04-24T02:06:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-实现一个类">1. 实现一个类</h2>
<p>定义一个完整类的格式应该是</p>
<p>[类访问修饰符] [修饰符] 类名 [extend 父类名] [implements 接口列表]{<br>
...<br>
}</p>
<pre><code class="language-java">public class Employee{
    private String name;
    private double salary;
    ... 
}
</code></pre>
<p>类访问修饰符：</p>
<table>
<thead>
<tr>
<th>类访问修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可以被所有类访问，注意public类的所在的文件名应该与该类名相同,一个java文件至多有一个public类</td>
</tr>
<tr>
<td>package (缺省)</td>
<td>仅能被相同包中的类访问，缺省的值</td>
</tr>
</tbody>
</table>
<p>修饰符:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>使用此修饰符的类不能被继承</td>
<td></td>
</tr>
<tr>
<td>abstract</td>
<td>声明这个类是一个抽象类</td>
<td>含有抽象方法的类必须声明为抽象类，但是抽象类不一定含有抽象方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Python对比：Python由于鸭子类型的存在，很少使用接口和抽象类，但在需要使用时，可以使用ABCMeta元类和abstractmethod装饰器来实现,参考<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p12_define_interface_or_abstract_base_class.html">Python3 Cookbook</a></p>
</blockquote>
<h2 id="2-类中的成员">2. 类中的成员</h2>
<p>Java 类中的成员可以为变量、方法、构造器和初始化块。</p>
<h3 id="实例成员和类成员静态成员">实例成员和类成员(静态成员)</h3>
<p>Java 类中的成员分为实例成员和类成员, 没有加 static 修饰符的成员为实例成员，加了 static 修饰符的成员为类成员,或者说静态成员，构造方法不能被 static 修饰。</p>
<pre><code class="language-java">public class Employee{
    private int id; // 实例变量
    private static int last_id; // 类变量

    static { // 静态初始化块
        last_id = 0;
    }

    Employee(){ // 构造方法
        last_id += 1;
        this.id = last_id;
    }

    // 实例方法
    public int get_id(){
        return this.id;
    }

    // 类方法
    public static int get_last_id(){
        return last_id;
    }
}
</code></pre>
<p>需要注意，静态方法不能访问实例成员，可以在实例上调用静态方法。 静态方法常用于工厂模式，关于初始化块的内容会在后面介绍。</p>
<blockquote>
<p>Python对比：Python中也有实例成员和类成员，其中类变量和实例变量与Java中基本类似，但是Python中静态方法和类方法是两种不同的方法类型，分别用<code>@staticmethod</code> 和 <code>@classmethod</code>装饰器装饰，<code>@classmethod</code>装饰的类方法更接近与Java中的类方法，因为其能够访问到类中定义的其他类成员。上述代码的Python实现如下:</p>
</blockquote>
<pre><code class="language-python">class Employee:
    last_id  = 0

    def __init__(self):
        # (self.类变量名)只能用来访问类变量
        # 修改时必须用(类名.变量名)
        # 否则会导致类变量变成实例变量
        Employee.last_id +=1
        self.id = self.last_id
    
    def get_id(self):
        return self.id
    
    @classmethod
    def get_last_id(cls):
        return cls.last_id

</code></pre>
<h3 id="成员的访问修饰符">成员的访问修饰符</h3>
<p>Java 中可以对类中的成员使用访问修饰符，Java 支持四中成员访问修饰符，对应的访问等级如下， 注意其与类访问修饰符的联系。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>子孙类</th>
<th>其他包</th>
<th>其他包子孙类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>Y/N（说明）</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>public</code>: 公用访问修饰符， 其修饰的成员可以被任何其他类访问，所有的公有成员都可以被子类继承。</p>
</li>
<li>
<p><code>protect</code>: 受保护的访问修饰符，相较于 public，其修饰的成员不能被其他包中的非子孙类访问，对于子孙类，要分为同包子孙类和非同包子孙类分析。 对于同包子孙类，所有 procted 的成员都可以被访问； 对于非同包的子孙类，较为复杂，可以参考<a href="http://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html">Java protected 关键字详解<br>
</a>。</p>
</li>
<li>
<p><code>default</code>: 默认访问修饰符，可以被当前类和同一包内的其他类访问。</p>
</li>
<li>
<p><code>private</code>: 私有访问修饰符，最严格的访问修饰符，只能被当前类访问。</p>
</li>
</ul>
<h3 id="final和static修饰符">final和static修饰符</h3>
<p>static 修饰符在前面已经学习过了，用来定义类级成员。 而 final 修饰符在学习类修饰符时也有提到，被 final 修饰的类不能被继承，其修饰修饰变量和修饰方法时，作用也是类似的。</p>
<p>final修饰的变量： 表示常量，只能被赋值一次，不能被修改。final 修饰的方法：不能被子类覆盖，但是可以被子类继承。</p>
<h3 id="初始化块">初始化块</h3>
<p>初始化块可以分为普通的初始化块和静态初始化块</p>
<p>普通初始化块： 从某种程度上来说，是构造函数的补充。</p>
<ul>
<li>普通初始化块总是在构造函数之前执行</li>
<li>与构造函数相比，他不接受任何参数。</li>
<li>一般的使用场景是需要初始化的内容不需要任何参数时，可以提取到初始化块中执行，比如多个构造器中的相同代码可以提取到初始化快中，提高初始化代码的复用。</li>
</ul>
<p>静态初始化块：</p>
<ul>
<li>在类初始化的阶段调用静态初始化块，而不是创建对象时，因此<strong>总是比普通初始化块要早执行</strong></li>
<li>只能对静态成员进行初始化，而不能对实例成员进行初始化。</li>
<li>只能访问静态成员。</li>
</ul>
<h3 id="构造器与this">构造器与this</h3>
<p>构造器是类中的一个特殊的方法，要求其方法名与类名相同，并且不返回然和类型。 其访问修饰符默认是 public 的。 如果指定了其返回值，该方法就只是一个普通方法。</p>
<p>构造器可以重载，可以使用this语句访问类中的其他实例成员，也可以用 this() 方法访问其他的重载的构造器。</p>
<h2 id="包的使用">包的使用</h2>
<p>要把一个类放到包中，需要将包的声明作为源文件的第一个声明。<br>
如</p>
<pre><code class="language-java">package com.gaoliang.learn_java;

public class Employee{
    ...
}
</code></pre>
<p>如果子目录和包的声明相同，即com/gaoliang/learn_java/Employee.java,则执行</p>
<pre><code class="language-bash">javac com/gaoliang/learn/Employee.java
</code></pre>
<p>会在对应的目录产生class文件，然后可以通过全限定的类名运行程序</p>
<pre><code class="language-bash">java com.gaoliang.learn.Employee
</code></pre>
<h3 id="类路径">类路径</h3>
<p>可以把class文件放到一个或者多个JAR文件中，</p>
<pre><code>jar cvf library.jar /path/to/*.class ...
</code></pre>
<p>如果要试用这些jar文件，则需要通过class path告诉编译器和虚拟机jar文件的位置。class path可以包含</p>
<ul>
<li>包含class文件的目录（包含匹配包名的子目录）</li>
<li>JAR文件</li>
<li>包含JAR文件的目录</li>
</ul>
<p>javac和java命令都有-classpath参数，可以缩写成 -cp，例如</p>
<pre><code class="language-bash">java -cp .:../libs/lib1.jar:../libs/lib2.jar com.mycompany.Mainclass
</code></pre>
<h3 id="导入包">导入包</h3>
<h4 id="import语句">import语句</h4>
<p>import语句可以使用户无需使用全限定名的使用类，例如</p>
<pre><code class="language-java">import java.util.Random;
Random random =  new Random()
</code></pre>
<p>可以使用通配符一次导入一个包中的所有类</p>
<pre><code class="language-java">import java.util.*;
</code></pre>
<p>但是要注意的是通配符只能用来导入类，不能通配的导入包。<br>
如果出现类名称冲突，需要手动导入自己想要的具体类，手动解决冲突。</p>
<h4 id="静态导入">静态导入</h4>
<p>静态导入使用户可以以 import 声明的形式导入静态的方法和变量，例如</p>
<pre><code class="language-java">import static java.lang.Math.*;
sqrt(12);
</code></pre>
<p><code>sqrt</code>是 Math 类的一个静态方法，可以用<code>import static</code>直接导入。</p>
<h3 id="嵌套类">嵌套类</h3>
<p>除了将类组织成包，还可以将一个类定义在另一个类的内部。 这样的类称为嵌套类。</p>
<h4 id="静态嵌套类">静态嵌套类</h4>
<p>首先看一个例子</p>
<pre><code class="language-java">public class Order{

    private static class Item{
        String description;
        int quality;
        double unitPrice;
        double price() {return quantity * unitPrice;}
    }
    
    private ArrayList&lt;Item&gt; items = new ArrayList&lt;&gt;();
    ...
}
</code></pre>
<p>这个例子中的 Item 是一个静态嵌套类，由于其使用 private 进行修饰，所以只有Order 类能够使用该类，如果使用 public 进行修饰，由于同时还是一个 static 的类， 所以可以被其他类在外部通过 Order.Item 进行使用。 所以静态嵌套类更像是为一个类增加了一个命名空间，更明显的表示Item是专属与 Order 的，而对于Order 和 Item 来说，两者并没有直接的关系。</p>
<h4 id="内部类">内部类</h4>
<p>如果去掉 static 修饰，那么这个嵌套类就变成了内部类。 内部类与静态嵌套类的最大区别是内部类可以获知自己所属的外部类实例。</p>
<pre><code class="language-java">import java.util.ArrayList;

public class ClassRoom {

    public class Student {
        String name;
        int age;

        public Student(String name, int age) {
            this.name = name;
            this.age = age;
        }
        // 注意这里，student是可以获取外部类的引用的
        // 所以可以使用外部类的变量和方法，比如这里的students
        public void leave() {
            students.remove(this);
            // 也可以写成这样，ClassRoom.this就是外部类实例的引用。
            // ClassRoom.this.students.remove(this);
        }
    }

    private ArrayList&lt;Student&gt; students = new ArrayList&lt;&gt;();

    public Student enroll(String name, int age) {
        Student newStudent = new Student(name, age);
        // 其实是 Student newStudent  = this.new Student(name, age)
        students.add(newStudent);
        return newStudent;
    }
}
</code></pre>
<p>去掉了 static， 出现了本质区别， 此时的 Student 类是知道自己所属于的 ClassRoom 实例的，并且可以使用<code>OutClass.this</code>获取外部类实例的引用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 常用 API 总结]]></title>
        <id>https://gaoliang.me/post/redis-commonly-used-apis</id>
        <link href="https://gaoliang.me/post/redis-commonly-used-apis">
        </link>
        <updated>2018-04-15T12:29:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用基本命令">常用基本命令</h2>
<ul>
<li><code>keys [pattern]</code> 所有满足pattern的key，一般不用 O(n)</li>
<li><code>dbsize</code> 所有key的总数 O(1)</li>
<li><code>exists key</code> 检查key是否存在 O(1)</li>
<li><code>del key</code> 删除指定的key-value，可以删除多个 O(1)</li>
<li><code>expire key seconds</code> 设置key在seconds秒之后过期 O(1)</li>
<li><code>ttl key</code> 查询key剩余的过期时间 O(1)</li>
<li><code>persist key</code> 去掉过期时间，不再过期 O(1)</li>
<li><code>type key</code>  返回key的类型[string hash list set zset none] O(1)</li>
</ul>
<h2 id="数据结构api">数据结构API</h2>
<p>redis 对外的数据类型有 string，hash，list，set，sorted set，但对于同一种数据类型的不同键值对，其内部的编码方式可能不同。 我们可以用<code>OBJECT ENCODING key</code> 命令来查看对应的key的内部编码方式。</p>
<h3 id="string-字符串">string 字符串</h3>
<p>字符串类型的结构： key -&gt; value<br>
内部编码包括 raw, int, embstr<br>
常用API：</p>
<ul>
<li><code>get key</code> 获取key的value</li>
<li><code>getrange key start end</code> 获取子串</li>
<li><code>mget key1 key2 key3</code>  批量获取，为原子操作</li>
<li><code>set key value</code> 设置key为value</li>
<li><code>setnx key value</code> 当key不存在时，设置key为value</li>
<li><code>set key value xx</code> 当key存在时才设置</li>
<li><code>setrange key index value</code> 指定下标设置一个新的值</li>
<li><code>mset key1 value1 key2 value2</code> 批量设置值</li>
<li><code>getset key newvalue</code> 返回旧值并设置新值</li>
<li><code>append key value</code> 追加字符串</li>
<li><code>strlen key</code> 获取value的长度（字节数）O(1) 可得内部其实记录了字符串的长度。</li>
<li><code>del key</code> 删除</li>
<li><code>incr key</code>  +1</li>
<li><code>decr key</code> -1</li>
<li><code>incrby key k</code> +k</li>
<li><code>decrby key k</code> -k</li>
</ul>
<h3 id="hash-哈希">hash 哈希</h3>
<p>hash类型的结构: key==&gt;{filed1: value1 field2: value2 ... }  可以看做是一个关系型数据库的一张表，虽然不太恰当</p>
<p>特点： 其实像是个small redis，或者map map。 注意filed不能相同，value可以相同。</p>
<p>内部编码包括 hashtable, ziplist</p>
<p>常用API</p>
<ul>
<li><code>hget key field</code> 获取hash key的field字段值</li>
<li><code>hmget key field1 field2 field3...</code> 一次获取多个filed的值</li>
<li><code>hset key field value</code> 设置hash key的filed字段值为value</li>
<li><code>hmset key field1 value1 filed2 value2 ...</code> 一次设置多个值</li>
<li><code>hdel key field</code> 删除</li>
<li><code>hexists key field</code> 判断hash key是否有field</li>
<li><code>hlen key</code> 获取hash key有多少个字段</li>
<li><code>hgetall key</code> 获取key中所有对应的field和value PS. 小心使用下面这三个命令</li>
<li><code>hvals key</code> 返回hash key中所有field的values</li>
<li><code>hkeys key</code> 返回hash key对应的所有的field</li>
</ul>
<p>可以发现，很多的API都是可以和string类型对应起来的，很多时候只是加了个h</p>
<h3 id="list-列表">list 列表</h3>
<p>list类型的结构: key==&gt;elements[a,b,c,...]<br>
特点： 有序，可重复，双端操作<br>
内部编码：linkedlist, ziplist<br>
常用API:</p>
<ul>
<li><code>rpush key value1 value2 ...</code> 从右端插入值,同样还有<code>lpush</code></li>
<li><code>rpop key</code> 从列表右端弹出一个item,同样的还有<code>lpop</code></li>
<li><code>linsert key before|after value newValue</code> 在list的指定值前插入newValue</li>
<li><code>lrem key count value</code>  根据count值，从列表中删除所有value相等的项，如果count&gt;0 则从左到右删除， 如果count&lt;0 则从右往左删，如果count=0，则删除全部value值</li>
<li><code>lrange key start end</code> 获取列表指定索引范围内的所有item，注意包含end，且支持负索引</li>
<li><code>ltrim key start end</code> 按照索引范围修剪列表</li>
<li><code>llen key</code> 获取列表的长度</li>
<li><code>lset key index newValue</code> 设置列表指定索引值为newValue</li>
<li><code>brpop key timeout</code> 在没有元素时，阻塞直到有元素能够pop，类似的还有<code>blpop</code>,在做消息队列的时候会很有用</li>
</ul>
<h3 id="set-集合">set 集合</h3>
<p>set类型的结构 key==&gt; {a,b,c,d}<br>
特点：无序，不可重复，支持集合间操作<br>
内部编码：hashtable intset</p>
<h4 id="集合内的api">集合内的API：</h4>
<ul>
<li><code>sadd key element1 element2 ...</code> 添加元素，如果存在则添加失败 O(1)</li>
<li><code>srem key element1 element2 ...</code> 移除元素 O(1)</li>
<li><code>scard key</code> 计算集合的大小</li>
<li><code>sismember key element</code> 判断是否在集合中</li>
<li><code>srandmember key count</code> 从集合中随机挑选count个元素，不会破坏集合</li>
<li><code>spop key</code> 从集合中随机弹出一个元素，注意是弹出，元素就从集合中移除了</li>
<li><code>smembers key</code> 所有元素，注意可能会导致阻塞，小心使用</li>
</ul>
<h4 id="集合间的api">集合间的API</h4>
<ul>
<li><code>sdiff key1 key2</code> 获取差集</li>
<li><code>sinter key1 key2</code> 获取交集</li>
<li><code>sunion key1 key</code> 获取并集</li>
</ul>
<h3 id="sorted-set-zset-有序集合">sorted set (zset) 有序集合</h3>
<p>set类型的结构 key==&gt; {score1:value1, score2:value2, ...}<br>
特点：有序，不可重复<br>
内部编码：skiplist ziplist<br>
常用API:</p>
<ul>
<li><code>zadd key score element</code> 注意score可以重复，但element不可以重复,时间复杂度为O(logN)</li>
<li><code>zrem key element</code> 删除，复杂度为O(1)</li>
<li><code>zscore key elment</code> 获取score</li>
<li><code>zincrby key increSocre elemnt</code> 增加指定元素的score</li>
<li><code>zcard key</code> 获取元素个数 时间复杂度为O(1)</li>
<li><code>zrank key element</code> 获取元素的排名</li>
<li><code>zrange key start end [WITHSCORES]</code> 返回指定排名范围的元素，并指定是否返回分数，时间复杂度为O(log(n) + m)</li>
<li><code>zrangebyscore key start end [WITHSCORES]</code> 返回指定score范围的元素，并指定是否返回分数，时间复杂度为O(log(n) + m)</li>
<li><code>zount key minScore maxScore</code> 返回指定score范围的元素个数，时间复杂度为O(log(n) + m)</li>
<li><code>zremrangebyrank key start end</code> 删除指定排名范围的元素 时间复杂度为O(log(n) + m)</li>
<li><code>zremrangebyscore key start end</code> 删除指定score范围的元素 时间复杂度为O(log(n) + m)</li>
</ul>
<h2 id="一些问题">一些问题</h2>
<h3 id="为什么单线程还这么快">为什么单线程还这么快？</h3>
<ol>
<li>纯内存操作</li>
<li>采用非阻塞IO, 内部io模型利用epoll并进行了优化</li>
<li>没有线程的切换，没有线程切换和竞态消耗</li>
</ol>
<h3 id="怎样避免单线程导致的阻塞问题">怎样避免单线程导致的阻塞问题？</h3>
<p>拒绝长慢命令，包括keys, flushall, flushdb等，不要在线上执行</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis 的持久化机制]]></title>
        <id>https://gaoliang.me/post/how-redis-do-persistence</id>
        <link href="https://gaoliang.me/post/how-redis-do-persistence">
        </link>
        <updated>2018-04-14T12:06:36.000Z</updated>
        <summary type="html"><![CDATA[<p>Redis 的持久化（Persistence）机制可以有效避免 redis 服务器在遇到故障时数据丢失的问题，发生故障重启后重新载入持久化的内容就可以恢复数据。redis 有两种持久化机制 RDB 和 AOF。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Redis 的持久化（Persistence）机制可以有效避免 redis 服务器在遇到故障时数据丢失的问题，发生故障重启后重新载入持久化的内容就可以恢复数据。redis 有两种持久化机制 RDB 和 AOF。</p>
<!-- more -->
<h2 id="持久化的一些概念">持久化的一些概念</h2>
<p>持久化一般有两种实现方式，一种是类似 MySQL 的 dump 命令的快照方式，这种方式每次调用会将数据库中的全部内容都一次性写入到硬盘中，恢复的时候也可以一次性将全部数据恢复出来。 另一种则是类似于 MySQL 的 Binlog 的方式，每当数据库内容更新时，记录下所有写操作的执行，恢复时，按照日志的顺序把所有的操作再执行一遍就可以恢复原来的数据。</p>
<h2 id="rdbredis-database-快照方式">RDB（Redis DataBase) 快照方式</h2>
<p>RDB 是利用快照实现的一种持久化技术，在 redis 中，内存中的数据经过 RDB 持久化后，会被保存到硬盘上的RDB二进制文件中，当我们需要恢复数据时，重新加载到内存中即可。 在进行快照时，如果系统中存在陈旧的快照，那么 RDB 会先新建快照，完成后再替换陈旧的快照。 每次持久化的时间复杂度为 O(n)。</p>
<h3 id="rdb-的触发方式">RDB 的触发方式</h3>
<h4 id="save-和-bgsave">save 和 bgsave</h4>
<p>save 和 bgsave 都可以通过用户主动调用的方式来完成数据的持久化，区别是save 是一个同步命令，执行时会阻塞 redis 的主线程，而 redis 又是单进程单线程的，这就会导致 save 执行的过程中，其他的指令只能排队阻塞等待执行。 bgsave 则是通过 fork() 系统调用新建一个子进程在后台完成数据持久化任务，不会阻塞主线程。<br>
他们的主要区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是(调用 fork() 时)</td>
</tr>
<tr>
<td>优点</td>
<td>不需要额外消耗内存</td>
<td>不会阻塞客户端其他命令</td>
</tr>
<tr>
<td>缺点</td>
<td>需要阻塞，部分场景不允许</td>
<td>fork消耗系统资源</td>
</tr>
</tbody>
</table>
<h4 id="自动触发">自动触发</h4>
<p>redis 会根据配置文件自动触发 bgsave 命令完成数据的持久化，通常情况下在 redis.conf 文件中我们会看到下面这样的配置项</p>
<pre><code>save 900 1
save 300 10
save 60 10000
</code></pre>
<p>save N M表示在 N 秒之内，redis 至少发生 M 次修改则 redis 抓快照到磁盘。 这个三条记录只要有一个满足要求就执行 bgsave 命令。一般项目中不启用自动触发</p>
<h4 id="其他的触发方式容易忽略的">其他的触发方式（容易忽略的）</h4>
<ul>
<li>全量复制（如主从复制时）</li>
<li>debug reload</li>
<li>shutdown</li>
</ul>
<h2 id="aofappend-only-file-日志方式">AOF（Append Only File） 日志方式</h2>
<p>RDB出现的问题：</p>
<ol>
<li>时间复杂度为O(n)，耗时耗性能</li>
<li>不可控，丢失数据，只有固定的时间点的数据会被持久化</li>
</ol>
<p>AOF的原理： 其实就是记录每一条命令，不过是保存在专有的 AOF 格式。AOF 的写入几乎是实时的。</p>
<h3 id="aof-的写入策略">AOF 的写入策略</h3>
<p>从内存中将数据复制到硬盘扇区是一项较为耗时的操作，redis 的 AOF 为我们提供了三种决定写入时机的策略，分别是 always, everysec 和 no。</p>
<h4 id="always-策略">always 策略</h4>
<p>每次执行命令都会调用 fsync 将命令写入到日志文件中，大数据量时非常慢但是十分安全。这种方式 IO 开销很大，对于一般的 sata 盘只有几百 TPS。</p>
<h4 id="everysec-策略">everysec 策略</h4>
<p>每秒将 redis 缓冲区中缓存的命令调用 fsync 写入到 aof 日志文件中，速度快了很多但是可能会丢失最近一秒的数据。</p>
<h4 id="no-策略">no 策略</h4>
<p>操作系统决定何时应该刷新，不可控</p>
<h3 id="aof-重写">AOF 重写</h3>
<p>当我们写入的命令很多之后，aof文件就会变得非常大，为了尽可能优化aof文件的大小，加快恢复的速度，会对aof文件进行重写。</p>
<h4 id="aof-重写的两种方式">AOF 重写的两种方式</h4>
<ol>
<li>bgrewriteaof 命令（利用fork异步进行）</li>
<li>自动重写，有两个配置项，auto-aof-rewrite-min-size，表示需要进行重写的尺寸和 auto-aof-rewrite-percentage，表示aof文件的增长率。同时满足两个条件时则 redis 会自动进行重写。</li>
</ol>
<h2 id="rdb-和-aof-的对比">RDB 和 AOF 的对比</h2>
<table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>恢复优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>轻重</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>